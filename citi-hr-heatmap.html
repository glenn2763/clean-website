<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Citi Field HR Seat Heatmap</title>
	<link rel="icon" href="/images/favicon.ico" />
	<style>
		body {
			margin: 0;
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
			background: #0b132b;
			color: #edf2f4;
		}
		.header {
			position: sticky;
			top: 0;
			z-index: 2;
			background: rgba(11,19,43,0.9);
			backdrop-filter: blur(6px);
			padding: 12px 16px;
			border-bottom: 1px solid rgba(255,255,255,0.08);
		}
		.container {
			padding: 16px;
		}
		.controls {
			display: flex;
			gap: 12px;
			flex-wrap: wrap;
			align-items: center;
			margin-bottom: 12px;
		}
		.canvas-wrap {
			position: relative;
			width: 100%;
			max-width: 1400px;
			margin: 0 auto;
		}
		#stadium {
			width: 100%;
			border-radius: 8px;
			box-shadow: 0 10px 30px rgba(0,0,0,0.35);
			display: block;
		}
		#overlay {
			position: absolute;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			pointer-events: auto;
		}
		.loading {
			position: absolute;
			left: 50%;
			top: 50%;
			transform: translate(-50%, -50%);
			background: rgba(0,0,0,0.7);
			padding: 8px 12px;
			border-radius: 6px;
			font-size: 13px;
			z-index: 3;
			display: none;
		}
		.tooltip {
			position: absolute;
			z-index: 3;
			padding: 6px 8px;
			background: rgba(0,0,0,0.8);
			border: 1px solid rgba(255,255,255,0.15);
			color: #fff;
			font-size: 12px;
			border-radius: 4px;
			pointer-events: none;
			opacity: 0;
			transform: translate(-50%, -120%);
		}
		.legend {
			display: flex;
			align-items: center;
			gap: 8px;
			margin-top: 8px;
			font-size: 12px;
			color: #c7d3ed;
		}
		.legend .bar {
			flex: 1;
			height: 10px;
			background: linear-gradient(90deg, #2a9d8f, #e9c46a, #e76f51);
			border-radius: 6px;
		}
		.small {
			font-size: 12px;
			opacity: 0.9;
		}
		.footer {
			margin-top: 20px;
			font-size: 12px;
			opacity: 0.8;
		}
	</style>
</head>
<body>
	<div class="header">
		<div class="container">
			<h2 style="margin:0;">Citi Field HR Seat Heatmap</h2>
			<div class="small">Hover for estimated probability a HR lands on that seat area. Data: last 3 seasons, regular season, all teams.</div>
		</div>
	</div>
	<div class="container">
		<div class="controls">
			<label>Seasons:
				<select id="seasons" multiple size="3">
					<option value="2023" selected>2023</option>
					<option value="2024" selected>2024</option>
					<option value="2025" selected>2025</option>
				</select>
			</label>
			<button id="reload">Reload</button>
			<div class="legend">
				<span>Low</span>
				<div class="bar"></div>
				<span>High</span>
			</div>
		</div>
		<div class="canvas-wrap" id="wrap">
			<img id="stadium" alt="Citi Field seating" crossorigin="anonymous" referrerpolicy="no-referrer" src="images/seatmap-citi-field.svg" />
			<canvas id="overlay"></canvas>
			<div class="tooltip" id="tooltip"></div>
			<div class="loading" id="loading">Loading Statcast dataâ€¦</div>
		</div>
		<div class="footer">Seat map image credit: Wikipedia contributors. Not affiliated with MLB or the New York Mets.</div>
	</div>

	<script>
	const overlay = document.getElementById('overlay');
	const stadium = document.getElementById('stadium');
	const wrap = document.getElementById('wrap');
	const tooltip = document.getElementById('tooltip');
	const seasonsSelect = document.getElementById('seasons');
	const reloadBtn = document.getElementById('reload');
	const loadingEl = document.getElementById('loading');

	let heatGrid = null;
	let total = 0;

	function getSelectedSeasons() {
		return Array.from(seasonsSelect.selectedOptions).map(o => o.value);
	}

	function resizeCanvasToImage() {
		const rect = stadium.getBoundingClientRect();
		overlay.width = rect.width;
		overlay.height = rect.height;
	}

	function kernelDensity(points, width, height, cellSize=8, bandwidth=22) {
		const cols = Math.ceil(width / cellSize);
		const rows = Math.ceil(height / cellSize);
		const grid = new Array(rows).fill(0).map(() => new Array(cols).fill(0));
		const sigma2 = bandwidth * bandwidth;
		const twoPiSigma2 = 2 * Math.PI * sigma2;
		const n = Math.max(1, points.length);
		for (const p of points) {
			const x = p.x * width;
			const y = p.y * height;
			const c0 = Math.max(0, Math.floor((x - 3*bandwidth) / cellSize));
			const c1 = Math.min(cols - 1, Math.ceil((x + 3*bandwidth) / cellSize));
			const r0 = Math.max(0, Math.floor((y - 3*bandwidth) / cellSize));
			const r1 = Math.min(rows - 1, Math.ceil((y + 3*bandwidth) / cellSize));
			for (let r = r0; r <= r1; r++) {
				for (let c = c0; c <= c1; c++) {
					const gx = c * cellSize + cellSize/2;
					const gy = r * cellSize + cellSize/2;
					const dx = gx - x;
					const dy = gy - y;
					const w = Math.exp(-(dx*dx + dy*dy) / (2*sigma2)) / twoPiSigma2;
					grid[r][c] += w;
				}
			}
		}
		// Normalize to probabilities summing to 1 across all cells
		let sum = 0;
		for (let r = 0; r < rows; r++) {
			for (let c = 0; c < cols; c++) sum += grid[r][c];
		}
		if (sum > 0) {
			for (let r = 0; r < rows; r++) {
				for (let c = 0; c < cols; c++) grid[r][c] /= sum;
			}
		}
		return { grid, rows, cols, cellSize };
	}

	function colorScale(t) {
		// 0..1 -> gradient teal->yellow->red
		const stops = [
			{ r:42, g:157, b:143 },
			{ r:233, g:196, b:106 },
			{ r:231, g:111, b:81 }
		];
		const x = Math.max(0, Math.min(1, t));
		const a = Math.floor(x * (stops.length - 1));
		const b = Math.min(stops.length - 1, a + 1);
		const f = x * (stops.length - 1) - a;
		const c0 = stops[a];
		const c1 = stops[b];
		const r = Math.round(c0.r + (c1.r - c0.r) * f);
		const g = Math.round(c0.g + (c1.g - c0.g) * f);
		const bb = Math.round(c0.b + (c1.b - c0.b) * f);
		return `rgba(${r}, ${g}, ${bb}, 0.75)`;
	}

	function drawHeatmap(kde) {
		const ctx = overlay.getContext('2d');
		ctx.clearRect(0, 0, overlay.width, overlay.height);
		const { grid, rows, cols, cellSize } = kde;
		let max = 0;
		for (let r = 0; r < rows; r++) {
			for (let c = 0; c < cols; c++) max = Math.max(max, grid[r][c]);
		}
		for (let r = 0; r < rows; r++) {
			for (let c = 0; c < cols; c++) {
				const val = grid[r][c] / max; // 0..1
				if (val <= 0) continue;
				ctx.fillStyle = colorScale(val);
				ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
			}
		}
	}

	function setupHover(kde) {
		overlay.onmousemove = (e) => {
			const rect = overlay.getBoundingClientRect();
			const x = e.clientX - rect.left;
			const y = e.clientY - rect.top;
			const c = Math.floor(x / kde.cellSize);
			const r = Math.floor(y / kde.cellSize);
			if (r < 0 || c < 0 || r >= kde.rows || c >= kde.cols) {
				tooltip.style.opacity = 0;
				return;
			}
			let max = 0;
			for (let rr = 0; rr < kde.rows; rr++) {
				for (let cc = 0; cc < kde.cols; cc++) max = Math.max(max, kde.grid[rr][cc]);
			}
			const prob = kde.grid[r][c];
			const pct = (prob * 100).toFixed(3);
			tooltip.textContent = `${pct}% chance in this seat area`;
			tooltip.style.left = `${e.clientX}px`;
			tooltip.style.top = `${e.clientY}px`;
			tooltip.style.opacity = 1;
		};
		overlay.onmouseleave = () => { tooltip.style.opacity = 0; };
	}

	async function fetchScheduleGamePksForYear(year) {
		const start = `${year}-01-01`;
		const end = `${year}-12-31`;
		const url = `https://statsapi.mlb.com/api/v1/schedule?sportId=1&startDate=${start}&endDate=${end}&venueIds=3289&gameType=R`;
		const res = await fetch(url);
		if (!res.ok) throw new Error('Failed schedule fetch');
		const data = await res.json();
		const pks = [];
		for (const date of data.dates || []) {
			for (const game of date.games || []) {
				if (game.gamePk) pks.push(game.gamePk);
			}
		}
		return pks;
	}

	async function fetchAllGamePks(years) {
		const lists = await Promise.all(years.map(fetchScheduleGamePksForYear));
		return lists.flat();
	}

	async function fetchHrPointsForGame(gamePk) {
		const url = `https://statsapi.mlb.com/api/v1.1/game/${gamePk}/feed/live`;
		const res = await fetch(url);
		if (!res.ok) return [];
		const data = await res.json();
		const plays = (((data || {}).liveData || {}).plays || {}).allPlays || [];
		const points = [];
		for (const p of plays) {
			const result = p.result || {};
			const isHr = (result.event || '').toLowerCase() === 'home run' || (result.eventType || '').toLowerCase() === 'home_run';
			if (!isHr) continue;
			const hitData = (p.hitData || {});
			const coords = hitData.coordinates || {};
			const x = Number(coords.coordX);
			const y = Number(coords.coordY);
			if (Number.isFinite(x) && Number.isFinite(y)) {
				points.push({ x: Math.max(0, Math.min(250, x)) / 250, y: Math.max(0, Math.min(250, y)) / 250 });
			}
		}
		return points;
	}

	async function fetchHrPoints(gamePks, concurrency = 10) {
		const results = [];
		let idx = 0;
		async function worker() {
			while (idx < gamePks.length) {
				const i = idx++;
				const pk = gamePks[i];
				try {
					const pts = await fetchHrPointsForGame(pk);
					results.push(...pts);
				} catch {}
			}
		}
		const workers = new Array(concurrency).fill(0).map(worker);
		await Promise.all(workers);
		return results;
	}

	async function loadData() {
		const seasons = getSelectedSeasons();
		loadingEl.style.display = 'block';
		try {
			const gamePks = await fetchAllGamePks(seasons);
			resizeCanvasToImage();
			const points = await fetchHrPoints(gamePks, 8);
			total = points.length;
			const kde = kernelDensity(points, overlay.width, overlay.height);
			drawHeatmap(kde);
			setupHover(kde);
		} finally {
			loadingEl.style.display = 'none';
		}
	}

	stadium.addEventListener('load', () => {
		resizeCanvasToImage();
		loadData().catch(err => console.error(err));
	});
	let imgFallbackStage = 0;
	stadium.addEventListener('error', () => {
		// 0: try Wikimedia SVG
		// 1: try local JPEG photo as last resort
		if (imgFallbackStage === 0) {
			imgFallbackStage = 1;
			stadium.src = 'https://upload.wikimedia.org/wikipedia/commons/8/8e/Citi_Field_seating_bowl_diagram.svg';
			return;
		}
		if (imgFallbackStage === 1) {
			imgFallbackStage = 2;
			stadium.src = 'images/Citi Field.JPG';
		}
	});
	window.addEventListener('resize', () => {
		resizeCanvasToImage();
		// re-render heatmap after resize by refetching
		loadData().catch(err => console.error(err));
	});
	reloadBtn.addEventListener('click', () => {
		loadData().catch(err => console.error(err));
	});
	</script>
</body>
</html> 